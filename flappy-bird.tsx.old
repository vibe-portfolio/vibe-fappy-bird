"use client"

import type React from "react"
import { useEffect, useRef, useState, useCallback } from "react"

// Import modular components
import { PHYSICS, DIMENSIONS, COLORS } from './lib/config'
import { AssetManager } from './lib/assetManager'
import { AudioManager } from './lib/audioManager'
import { ParticleSystem } from './lib/particleSystem'
import { GameLogic } from './lib/gameLogic'
import { Renderer } from './lib/renderer'
import type { GameState, GameAssets, AudioBuffers } from './lib/types'

export default function SkyDash() {
  const canvasRef = useRef<HTMLCanvasElement>(null)
  const [assetsLoaded, setAssetsLoaded] = useState(false)
  const [loadingError, setLoadingError] = useState<string | null>(null)
  const [isGameOver, setIsGameOver] = useState(false)
  const [isGameStarted, setIsGameStarted] = useState(false)
  const [scale, setScale] = useState(1)

  // Game system instances
  const assetManagerRef = useRef<AssetManager>(new AssetManager())
  const audioManagerRef = useRef<AudioManager | null>(null)
  const particleSystemRef = useRef<ParticleSystem>(new ParticleSystem())
  const rendererRef = useRef<Renderer | null>(null)
  
  // Game state and timing
  const gameStateRef = useRef<GameState>(GameLogic.createInitialGameState())
  const lastFrameTimeRef = useRef<number>(0)
  const lastJumpTimeRef = useRef<number>(0)
  
  // Assets
  const assetsRef = useRef<GameAssets | null>(null)
  const audioBuffersRef = useRef<AudioBuffers | null>(null)

  // Calculate scale for mobile to fill screen while maintaining aspect ratio
  useEffect(() => {
    const updateScale = () => {
      if (window.innerWidth < 768) {
        // Mobile view - scale to fit screen
        const scaleX = window.innerWidth / DIMENSIONS.CANVAS_WIDTH
        const scaleY = window.innerHeight / DIMENSIONS.CANVAS_HEIGHT
        // Use the larger scale to ensure full coverage
        setScale(Math.max(scaleX, scaleY))
      } else {
        // Desktop view - no scaling
        setScale(1)
      }
    }

    updateScale()
    window.addEventListener("resize", updateScale)
    window.addEventListener("orientationchange", updateScale)

    return () => {
      window.removeEventListener("resize", updateScale)
      window.removeEventListener("orientationchange", updateScale)
    }
  }, [])

  // Load all game assets
  useEffect(() => {
    const loadAssets = async () => {
      try {
        const { assets, audioBuffers } = await assetManagerRef.current.loadAllAssets()
        
        assetsRef.current = assets
        audioBuffersRef.current = audioBuffers
        
        // Initialize audio manager
        audioManagerRef.current = new AudioManager(
          assetManagerRef.current.getAudioContext(),
          audioBuffers
        )
        
        // Initialize renderer
        const canvas = canvasRef.current
        if (canvas) {
          rendererRef.current = new Renderer(canvas, assets)
        }
        
        setAssetsLoaded(true)
      } catch (error) {
        console.error("Asset loading error:", error)
        setLoadingError(error instanceof Error ? error.message : 'Unknown error')
      }
    }

    loadAssets()
  }, [])

  // Game control functions
  const playSoundImmediately = useCallback((soundType: "point" | "hit" | "wing") => {
    audioManagerRef.current?.playSoundImmediately(soundType)
  }, [])

  const queueSound = useCallback((soundType: "point" | "hit" | "wing") => {
    audioManagerRef.current?.queueSound(soundType)
  }, [])

  const createParticles = useCallback((x: number, y: number, type: 'trail' | 'explosion' | 'score' | 'jump', count: number = 5) => {
    return particleSystemRef.current.createParticles(x, y, type, count)
  }, [])

  const jump = useCallback(() => {
    const state = gameStateRef.current
    const now = Date.now()

    // Prevent rapid-fire jumps
    if (now - lastJumpTimeRef.current < PHYSICS.JUMP_COOLDOWN) {
      return
    }
    lastJumpTimeRef.current = now

    // Initialize audio context on user interaction
    audioManagerRef.current?.initializeAudioContext()

    if (!state.gameOver && state.gameStarted) {
      GameLogic.jump(state.bird)
      playSoundImmediately("wing")
      // Add jump particles
      const jumpParticles = createParticles(50 + DIMENSIONS.BIRD_WIDTH/2, state.bird.y + DIMENSIONS.BIRD_HEIGHT/2, 'jump', 3)
      state.particles.push(...jumpParticles)
    } else if (!state.gameStarted) {
      state.gameStarted = true
      setIsGameStarted(true)
      lastFrameTimeRef.current = 0
    }
  }, [playSoundImmediately, createParticles])

  const restartGame = useCallback(() => {
    gameStateRef.current = GameLogic.createInitialGameState()
    gameStateRef.current.gameStarted = true
    setIsGameOver(false)
    setIsGameStarted(true)
    lastFrameTimeRef.current = 0
  }, [])

  useEffect(() => {
    const handleKeyPress = (e: KeyboardEvent) => {
      if (e.code === "Space") {
        e.preventDefault()
        const state = gameStateRef.current
        if (!state.gameStarted) {
          state.gameStarted = true
          setIsGameStarted(true)
          lastFrameTimeRef.current = 0
        } else if (!state.gameOver) {
          jump()
        }
      }
    }
    window.addEventListener("keydown", handleKeyPress)
    return () => window.removeEventListener("keydown", handleKeyPress)
  }, [jump])

  useEffect(() => {
    if (!assetsLoaded) return

    const canvas = canvasRef.current
    const ctx = canvas?.getContext("2d", {
      alpha: false,
      desynchronized: true,
    })
    if (!canvas || !ctx) return

    let animationFrameId: number

    const gameLoop = (currentTime: number) => {
      const state = gameStateRef.current

      // Play any pending sounds
      if (pendingSoundsRef.current.size > 0) {
        pendingSoundsRef.current.forEach((sound) => {
          playSoundImmediately(sound)
        })
        pendingSoundsRef.current.clear()
      }

      // Calculate delta time and clamp it
      if (lastFrameTimeRef.current === 0) {
        lastFrameTimeRef.current = currentTime
      }
      let deltaTime = (currentTime - lastFrameTimeRef.current) / (1000 / TARGET_FPS)
      // Clamp delta time to prevent huge jumps from frame drops or tab switching
      deltaTime = Math.min(deltaTime, MAX_DELTA_TIME)
      lastFrameTimeRef.current = currentTime

      // Update screen shake and flash effects
      if (state.screenShake > 0) {
        state.screenShake = Math.max(0, state.screenShake - 0.5)
      }
      if (state.flashEffect > 0) {
        state.flashEffect = Math.max(0, state.flashEffect - 0.05)
      }

      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height)

      // Apply screen shake
      const shakeX = state.screenShake > 0 ? (Math.random() - 0.5) * state.screenShake : 0
      const shakeY = state.screenShake > 0 ? (Math.random() - 0.5) * state.screenShake : 0
      ctx.save()
      ctx.translate(shakeX, shakeY)

      // Update background offset for parallax
      if (state.gameStarted && !state.gameOver) {
        state.backgroundOffset -= PIPE_SPEED * deltaTime * 0.3
      }

      // Draw parallax background layers
      if (backgroundImage.current) {
        const bgWidth = canvas.width
        const bgHeight = canvas.height
        
        // Far background (slowest)
        const farOffset = state.backgroundOffset * 0.2
        ctx.drawImage(backgroundImage.current, farOffset % bgWidth - bgWidth, 0, bgWidth, bgHeight)
        ctx.drawImage(backgroundImage.current, farOffset % bgWidth, 0, bgWidth, bgHeight)
        ctx.drawImage(backgroundImage.current, farOffset % bgWidth + bgWidth, 0, bgWidth, bgHeight)
        
        // Mid background
        const midOffset = state.backgroundOffset * 0.5
        ctx.globalAlpha = 0.7
        ctx.drawImage(backgroundImage.current, midOffset % bgWidth - bgWidth, 0, bgWidth, bgHeight)
        ctx.drawImage(backgroundImage.current, midOffset % bgWidth, 0, bgWidth, bgHeight)
        ctx.drawImage(backgroundImage.current, midOffset % bgWidth + bgWidth, 0, bgWidth, bgHeight)
        ctx.globalAlpha = 1
        
        // Add sophisticated gradient overlay for better visibility and atmosphere
        const overlayGradient = ctx.createLinearGradient(0, 0, 0, canvas.height)
        overlayGradient.addColorStop(0, 'rgba(15, 23, 42, 0.2)')  // Very subtle at top
        overlayGradient.addColorStop(0.7, 'rgba(15, 23, 42, 0.4)') // Stronger at bottom
        overlayGradient.addColorStop(1, 'rgba(15, 23, 42, 0.6)')   // Strongest at ground level
        ctx.fillStyle = overlayGradient
        ctx.fillRect(0, 0, canvas.width, canvas.height)
      }

      if (!state.gameStarted) {
        // Modern start screen overlay
        const startOverlayGradient = ctx.createRadialGradient(
          canvas.width / 2, canvas.height / 2, 0,
          canvas.width / 2, canvas.height / 2, canvas.width
        )
        startOverlayGradient.addColorStop(0, 'rgba(248, 250, 252, 0.1)')
        startOverlayGradient.addColorStop(1, 'rgba(15, 23, 42, 0.7)')
        ctx.fillStyle = startOverlayGradient
        ctx.fillRect(0, 0, canvas.width, canvas.height)
        
        // Draw message with enhanced styling
        if (messageImage.current) {
          const messageWidth = 184
          const messageHeight = 267
          const messageX = (canvas.width - messageWidth) / 2
          const messageY = (canvas.height - messageHeight) / 2
          
          // Add glow to start message
          ctx.shadowColor = COLORS.primary.glow
          ctx.shadowBlur = 10
          ctx.drawImage(messageImage.current, messageX, messageY, messageWidth, messageHeight)
          ctx.shadowBlur = 0
        }
        
        // Add modern "Tap to Start" text
        ctx.fillStyle = COLORS.neutral.white
        ctx.font = "18px -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif"
        ctx.textAlign = 'center'
        ctx.shadowColor = 'rgba(0, 0, 0, 0.8)'
        ctx.shadowBlur = 4
        ctx.fillText("Tap to Start", canvas.width / 2, canvas.height - 60)
        ctx.textAlign = 'start'
        ctx.shadowBlur = 0
        
        animationFrameId = requestAnimationFrame(gameLoop)
        return
      }

      if (!state.gameOver) {
        // Update bird position and animation frame with delta time
        state.bird.velocity += GRAVITY * deltaTime
        state.bird.y += state.bird.velocity * deltaTime

        state.frameCount++
        if (state.frameCount % 5 === 0) {
          state.bird.frame = (state.bird.frame + 1) % 3
        }

        // Add bird trail particles
        if (state.frameCount % 3 === 0) {
          const trailParticles = createParticles(50 + BIRD_WIDTH/2 - 10, state.bird.y + BIRD_HEIGHT/2, 'trail', 1)
          state.particles.push(...trailParticles)
        }

        // Move pipes with delta time
        const pipesToRemove: number[] = []
        for (let i = 0; i < state.pipes.length; i++) {
          const pipe = state.pipes[i]
          pipe.x -= PIPE_SPEED * deltaTime

          // Mark for removal if off-screen
          if (pipe.x + PIPE_WIDTH <= 0) {
            pipesToRemove.push(i)
          }
        }

        // Remove off-screen pipes (in reverse to avoid index issues)
        for (let i = pipesToRemove.length - 1; i >= 0; i--) {
          state.pipes.splice(pipesToRemove[i], 1)
        }

        // Generate new pipes
        if (state.pipes.length === 0 || state.pipes[state.pipes.length - 1].x < canvas.width - 200) {
          const topHeight = Math.random() * (canvas.height - PIPE_GAP - 100) + 50
          state.pipes.push({ x: canvas.width, topHeight, scored: false })
        }

        // Check collisions and scoring in a single loop
        const birdRect = { x: 50, y: state.bird.y, width: BIRD_WIDTH, height: BIRD_HEIGHT }

        for (const pipe of state.pipes) {
          // Scoring check
          if (!pipe.scored && pipe.x + PIPE_WIDTH < 50) {
            pipe.scored = true
            state.score++
            queueSound("point")
            // Add score particles
            const scoreParticles = createParticles(pipe.x + PIPE_WIDTH, pipe.topHeight + PIPE_GAP/2, 'score', 8)
            state.particles.push(...scoreParticles)
            // Flash effect
            state.flashEffect = 0.3
          }

          // Collision detection
          const topPipeRect = { x: pipe.x, y: 0, width: PIPE_WIDTH, height: pipe.topHeight }
          const bottomPipeRect = {
            x: pipe.x,
            y: pipe.topHeight + PIPE_GAP,
            width: PIPE_WIDTH,
            height: canvas.height - pipe.topHeight - PIPE_GAP,
          }

          if (
            birdRect.x < topPipeRect.x + topPipeRect.width &&
            birdRect.x + birdRect.width > topPipeRect.x &&
            birdRect.y < topPipeRect.y + topPipeRect.height &&
            birdRect.y + birdRect.height > topPipeRect.y
          ) {
            state.gameOver = true
            setIsGameOver(true)
            queueSound("hit")
            // Add explosion particles
            const explosionParticles = createParticles(birdRect.x + birdRect.width/2, birdRect.y + birdRect.height/2, 'explosion', 15)
            state.particles.push(...explosionParticles)
            // Screen shake
            state.screenShake = 8
            state.flashEffect = 0.5
            break
          }

          if (
            birdRect.x < bottomPipeRect.x + bottomPipeRect.width &&
            birdRect.x + birdRect.width > bottomPipeRect.x &&
            birdRect.y < bottomPipeRect.y + bottomPipeRect.height &&
            birdRect.y + birdRect.height > bottomPipeRect.y
          ) {
            state.gameOver = true
            setIsGameOver(true)
            queueSound("hit")
            // Add explosion particles
            const explosionParticles = createParticles(birdRect.x + birdRect.width/2, birdRect.y + birdRect.height/2, 'explosion', 15)
            state.particles.push(...explosionParticles)
            // Screen shake
            state.screenShake = 8
            state.flashEffect = 0.5
            break
          }
        }

        // Boundary check
        if (state.bird.y > canvas.height || state.bird.y < 0) {
          state.gameOver = true
          setIsGameOver(true)
          queueSound("hit")
          // Add explosion particles
          const explosionParticles = createParticles(50 + BIRD_WIDTH/2, state.bird.y + BIRD_HEIGHT/2, 'explosion', 15)
          state.particles.push(...explosionParticles)
          // Screen shake
          state.screenShake = 8
          state.flashEffect = 0.5
        }
      }

      // Update particles
      for (let i = state.particles.length - 1; i >= 0; i--) {
        const particle = state.particles[i]
        particle.x += particle.vx * deltaTime
        particle.y += particle.vy * deltaTime
        particle.life -= deltaTime
        
        // Add gravity to explosion particles
        if (particle.type === 'explosion') {
          particle.vy += 0.1 * deltaTime
        }
        
        // Remove dead particles
        if (particle.life <= 0) {
          state.particles.splice(i, 1)
        }
      }

      // Draw pipes with modern glow effect
      for (const pipe of state.pipes) {
        if (pipeImage.current) {
          // Add subtle glow effect with theme colors
          ctx.shadowColor = COLORS.secondary.glow
          ctx.shadowBlur = 8
          
          // Draw top pipe (flipped vertically)
          ctx.save()
          ctx.scale(1, -1)
          ctx.drawImage(pipeImage.current, pipe.x, -pipe.topHeight, PIPE_WIDTH, 320)
          ctx.restore()

          // Draw bottom pipe
          ctx.drawImage(pipeImage.current, pipe.x, pipe.topHeight + PIPE_GAP, PIPE_WIDTH, 320)
          
          // Add subtle highlight on pipe edges for depth
          ctx.shadowBlur = 0
          ctx.strokeStyle = COLORS.secondary.light
          ctx.lineWidth = 1
          ctx.globalAlpha = 0.3
          
          // Top pipe outline
          ctx.strokeRect(pipe.x, 0, PIPE_WIDTH, pipe.topHeight)
          // Bottom pipe outline  
          ctx.strokeRect(pipe.x, pipe.topHeight + PIPE_GAP, PIPE_WIDTH, canvas.height - pipe.topHeight - PIPE_GAP)
          
          ctx.globalAlpha = 1
        }
      }

      // Draw particles
      for (const particle of state.particles) {
        const alpha = particle.life / particle.maxLife
        ctx.globalAlpha = alpha
        
        ctx.fillStyle = particle.color
        ctx.beginPath()
        ctx.arc(particle.x, particle.y, particle.size * alpha, 0, Math.PI * 2)
        ctx.fill()
        
        // Add glow for certain particle types
        if (particle.type === 'score' || particle.type === 'explosion') {
          ctx.shadowColor = particle.color
          ctx.shadowBlur = 5
          ctx.beginPath()
          ctx.arc(particle.x, particle.y, particle.size * alpha * 0.5, 0, Math.PI * 2)
          ctx.fill()
          ctx.shadowBlur = 0
        }
      }
      ctx.globalAlpha = 1

      if (birdImage.current) {
        ctx.save()
        ctx.translate(50 + BIRD_WIDTH / 2, state.bird.y + BIRD_HEIGHT / 2)
        ctx.rotate(Math.min(Math.PI / 4, Math.max(-Math.PI / 4, state.bird.velocity * 0.1)))

        // Add radial shadow beneath the bird
        const shadowRadius = BIRD_WIDTH * 0.8
        const shadowGradient = ctx.createRadialGradient(0, BIRD_HEIGHT / 3, 0, 0, BIRD_HEIGHT / 3, shadowRadius)
        shadowGradient.addColorStop(0, 'rgba(0, 0, 0, 0.4)')
        shadowGradient.addColorStop(0.7, 'rgba(0, 0, 0, 0.2)')
        shadowGradient.addColorStop(1, 'rgba(0, 0, 0, 0)')
        
        ctx.save()
        ctx.globalCompositeOperation = 'multiply'
        ctx.fillStyle = shadowGradient
        ctx.beginPath()
        ctx.ellipse(0, BIRD_HEIGHT / 3, shadowRadius * 0.8, shadowRadius * 0.4, 0, 0, Math.PI * 2)
        ctx.fill()
        ctx.restore()

        // Add drop shadow
        ctx.shadowColor = 'rgba(0, 0, 0, 0.8)'
        ctx.shadowBlur = 4
        ctx.shadowOffsetX = 2
        ctx.shadowOffsetY = 2

        // Draw dark outline by drawing the image multiple times slightly offset
        ctx.globalCompositeOperation = 'source-over'
        const outlineSize = 2
        
        // Draw outline in 8 directions
        for (let x = -outlineSize; x <= outlineSize; x++) {
          for (let y = -outlineSize; y <= outlineSize; y++) {
            if (x !== 0 || y !== 0) {
              ctx.save()
              ctx.beginPath()
              ctx.arc(x, y, BIRD_WIDTH / 2, 0, Math.PI * 2)
              ctx.clip()
              ctx.filter = 'brightness(0)' // Make it black for outline
              ctx.drawImage(birdImage.current, -BIRD_WIDTH / 2 + x, -BIRD_HEIGHT / 2 + y, BIRD_WIDTH, BIRD_HEIGHT)
              ctx.restore()
            }
          }
        }

        // Draw the actual bird on top
        ctx.filter = 'none'
        ctx.beginPath()
        ctx.arc(0, 0, BIRD_WIDTH / 2, 0, Math.PI * 2)
        ctx.clip()
        ctx.drawImage(birdImage.current, -BIRD_WIDTH / 2, -BIRD_HEIGHT / 2, BIRD_WIDTH, BIRD_HEIGHT)
        
        ctx.restore()
      }

      // Draw score with modern design system
      const scoreString = state.score.toString()
      const digitWidth = 24
      const totalWidth = scoreString.length * digitWidth
      const startX = (canvas.width - totalWidth) / 2
      const padding = 16
      const borderRadius = 12
      
      // Modern score container with gradient background
      const scoreGradient = ctx.createLinearGradient(startX - padding, 15, startX - padding, 61)
      scoreGradient.addColorStop(0, 'rgba(248, 250, 252, 0.95)')  // Light top
      scoreGradient.addColorStop(1, 'rgba(226, 232, 240, 0.95)')  // Slightly darker bottom
      
      // Draw rounded rectangle background
      ctx.fillStyle = scoreGradient
      ctx.beginPath()
      ctx.roundRect(startX - padding, 15, totalWidth + (padding * 2), 46, borderRadius)
      ctx.fill()
      
      // Add subtle border
      ctx.strokeStyle = COLORS.primary.light
      ctx.lineWidth = 2
      ctx.stroke()
      
      // Add inner shadow for depth
      ctx.shadowColor = 'rgba(0, 0, 0, 0.1)'
      ctx.shadowBlur = 4
      ctx.shadowOffsetY = 2
      
      // Draw score digits with enhanced glow
      ctx.shadowColor = COLORS.primary.glow
      ctx.shadowBlur = 8
      
      for (let i = 0; i < scoreString.length; i++) {
        const digitImage = numberSprites.current[Number.parseInt(scoreString[i])]
        if (digitImage) {
          ctx.drawImage(digitImage, startX + i * digitWidth, 20, digitWidth, 36)
        }
      }
      ctx.shadowBlur = 0
      ctx.shadowOffsetY = 0

      // Apply flash effect
      if (state.flashEffect > 0) {
        ctx.fillStyle = `rgba(255, 255, 255, ${state.flashEffect})`
        ctx.fillRect(0, 0, canvas.width, canvas.height)
      }

      // Restore transform (remove screen shake)
      ctx.restore()

      if (state.gameOver) {
        // Modern game over overlay
        const overlayGradient = ctx.createRadialGradient(
          canvas.width / 2, canvas.height / 2, 0,
          canvas.width / 2, canvas.height / 2, canvas.width
        )
        overlayGradient.addColorStop(0, 'rgba(15, 23, 42, 0.7)')
        overlayGradient.addColorStop(1, 'rgba(15, 23, 42, 0.9)')
        ctx.fillStyle = overlayGradient
        ctx.fillRect(0, 0, canvas.width, canvas.height)
        
        if (gameOverImage.current) {
          const gameOverWidth = 192
          const gameOverHeight = 42
          const gameOverX = (canvas.width - gameOverWidth) / 2
          const gameOverY = (canvas.height - gameOverHeight) / 2 - 30
          
          // Add dramatic glow to game over text
          ctx.shadowColor = COLORS.danger.glow
          ctx.shadowBlur = 15
          ctx.drawImage(gameOverImage.current, gameOverX, gameOverY, gameOverWidth, gameOverHeight)
          ctx.shadowBlur = 0

          // Modern restart button with design system
          const buttonWidth = 120
          const buttonHeight = 48
          const buttonX = canvas.width / 2 - buttonWidth / 2
          const buttonY = canvas.height / 2 + 30
          const buttonRadius = 12
          
          // Button gradient using theme colors
          const buttonGradient = ctx.createLinearGradient(buttonX, buttonY, buttonX, buttonY + buttonHeight)
          buttonGradient.addColorStop(0, COLORS.primary.light)
          buttonGradient.addColorStop(1, COLORS.primary.main)
          
          // Draw rounded button
          ctx.fillStyle = buttonGradient
          ctx.beginPath()
          ctx.roundRect(buttonX, buttonY, buttonWidth, buttonHeight, buttonRadius)
          ctx.fill()
          
          // Button glow effect
          ctx.shadowColor = COLORS.primary.glow
          ctx.shadowBlur = 12
          ctx.stroke()
          ctx.shadowBlur = 0
          
          // Button border
          ctx.strokeStyle = COLORS.neutral.white
          ctx.lineWidth = 2
          ctx.globalAlpha = 0.8
          ctx.stroke()
          ctx.globalAlpha = 1
          
          // Modern typography for button text
          ctx.shadowColor = 'rgba(0, 0, 0, 0.5)'
          ctx.shadowBlur = 2
          ctx.shadowOffsetY = 1
          ctx.fillStyle = COLORS.neutral.white
          ctx.font = "bold 20px -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif"
          ctx.textAlign = 'center'
          ctx.fillText("Restart", canvas.width / 2, buttonY + buttonHeight / 2 + 7)
          ctx.textAlign = 'start'
          ctx.shadowBlur = 0
          ctx.shadowOffsetY = 0
          
          // Final score display
          ctx.fillStyle = COLORS.neutral.light
          ctx.font = "16px -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif"
          ctx.textAlign = 'center'
          ctx.fillText(`Final Score: ${state.score}`, canvas.width / 2, gameOverY - 10)
          ctx.textAlign = 'start'
        }
      }

      animationFrameId = requestAnimationFrame(gameLoop)
    }

    animationFrameId = requestAnimationFrame(gameLoop)

    return () => cancelAnimationFrame(animationFrameId)
  }, [assetsLoaded, playSoundImmediately, queueSound, createParticles])

  const handleCanvasClick = useCallback(
    (event: React.MouseEvent<HTMLCanvasElement>) => {
      const canvas = canvasRef.current
      if (!canvas) return

      const rect = canvas.getBoundingClientRect()
      const x = (event.clientX - rect.left) * (CANVAS_WIDTH / rect.width)
      const y = (event.clientY - rect.top) * (CANVAS_HEIGHT / rect.height)

      const state = gameStateRef.current

      if (state.gameOver) {
        // Check if click is within modern Restart button area
        const buttonWidth = 120
        const buttonHeight = 48
        const buttonX = CANVAS_WIDTH / 2 - buttonWidth / 2
        const buttonY = CANVAS_HEIGHT / 2 + 30
        
        if (
          x >= buttonX &&
          x <= buttonX + buttonWidth &&
          y >= buttonY &&
          y <= buttonY + buttonHeight
        ) {
          restartGame()
          return // Exit early to prevent jump
        }
      }

      // Only jump if we didn't restart
      jump()
    },
    [jump, restartGame],
  )

  const handleTouchStart = useCallback(
    (e: React.TouchEvent<HTMLCanvasElement>) => {
      e.preventDefault()
      e.stopPropagation()

      const canvas = canvasRef.current
      if (!canvas) return

      const rect = canvas.getBoundingClientRect()
      const touch = e.touches[0]
      const x = (touch.clientX - rect.left) * (CANVAS_WIDTH / rect.width)
      const y = (touch.clientY - rect.top) * (CANVAS_HEIGHT / rect.height)

      const state = gameStateRef.current

      if (state.gameOver) {
        // Check if touch is within modern Restart button area
        const buttonWidth = 120
        const buttonHeight = 48
        const buttonX = CANVAS_WIDTH / 2 - buttonWidth / 2
        const buttonY = CANVAS_HEIGHT / 2 + 30
        
        if (
          x >= buttonX &&
          x <= buttonX + buttonWidth &&
          y >= buttonY &&
          y <= buttonY + buttonHeight
        ) {
          restartGame()
          return // Exit early to prevent jump
        }
      }

      // Only jump if we didn't restart
      jump()
    },
    [jump, restartGame],
  )

  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-gray-100 overflow-hidden">
      {!assetsLoaded && !loadingError && (
        <div className="text-center">
          <div className="text-2xl font-bold mb-4">Loading Sky Dash...</div>
          <div className="animate-pulse text-gray-600">Please wait</div>
        </div>
      )}
      {loadingError && (
        <div className="text-center p-4 max-w-md">
          <div className="text-2xl font-bold mb-4 text-red-600">Loading Error</div>
          <div className="text-gray-700 mb-4">{loadingError}</div>
          <button
            onClick={() => window.location.reload()}
            className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
          >
            Retry
          </button>
        </div>
      )}
      {assetsLoaded && (
        <>
          <canvas
            ref={canvasRef}
            width={CANVAS_WIDTH}
            height={CANVAS_HEIGHT}
            className="border border-gray-300 touch-none md:border"
            style={{
              transform: `scale(${scale})`,
              transformOrigin: "center center",
              imageRendering: "pixelated",
            }}
            onClick={handleCanvasClick}
            onTouchStart={handleTouchStart}
          />
          <p className="hidden md:block mt-4 text-lg text-center px-4">Tap to soar or press Space to dash through the sky</p>
        </>
      )}
    </div>
  )
}
